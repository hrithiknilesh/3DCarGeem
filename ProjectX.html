<!-- filepath: c:\Users\nhsd\Desktop\Web\website\3DCarGeem\ProjectX.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My Car Geem</title>
  <style>
    /* Game Title Screen */
    #gameTitleScreen {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: absolute; /* Ensures the element is positioned relative to its closest positioned ancestor */
      top: 50%; /* Vertically centers the element */
      left: 50%; /* Horizontally centers the element */
      transform: translate(-50%, -50%); /* Offsets the element by 50% of its own size */
      background-color: rgb(0, 0, 0, 0.75); /* slight dark overlay */
      backdrop-filter: blur(16px); /* the actual blur */
      -webkit-backdrop-filter: blur(16px), brightness(0.2), ; /* Safari support */
      width: 100%; /* Adjusts width according to content, or you can set a specific width if necessary */
      height: 100%; /* Adjusts height according to content */
      opacity: 1; /* Initially visible */
      transition: opacity 0.5s ease-in-out; /* Fades out over 1 second */
    }

    #gameTitle {
      font-size: 72px;
      color: black;
    }

    #startButton {
      font-size: 18px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      padding: 15px 30px;
      margin-top: 20px;
      cursor: pointer;
      font-size: 20px;
      border-radius: 12px;
    }

    #startButton:hover {
      background-color: rgba(0, 0, 0, 0.55);
    }

    #speedDial {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      z-index: 10;
      display: none;
    }

    #displayMessage {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20%;
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      z-index: 10;
      display: none;
      opacity: 1;
      transition: opacity 1.5s;
    }

    #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100px;
      height: 100%;
      background-color: transparent;
      color: black;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 30;
      display: none;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    #toggleCarPickerBtn {
      background-color: #444;
      color: white;
      border: none;
      padding: 15px;
      margin-top: 20px;
      cursor: pointer;
      font-size: 18px;
      border-radius: 5px;
    }

    #toggleCarPickerBtn:hover {
      background-color: #555;
    }

    /* Car Picker UI */
    #carPicker {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      border-radius: 20px;
      border: 1px solid black;
      background-color: rgb(0, 0, 0, 0.75); /* slight dark overlay */
      backdrop-filter: blur(16px); /* the actual blur */
      -webkit-backdrop-filter: blur(16px), brightness(0.2), ; /* Safari support */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      display: none; /* Hidden by default */
    }
    
    #carPicker h1 {
      font-size: 36px;
      margin-bottom: 20px;
      color: black;
    }

    .gridContainer {
      max-height: 80vh; /* Adjust as needed */
      overflow-y: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 20px;
      width: 100%;
      max-width: 1000px;
      padding: 20px;
      box-sizing: border-box;
      background-color: white;
      opacity: 1;
    }

    .gridItem {
      width: 200px;
      height: 50px;
      background-color: black;
      margin: 8px;
      margin-left: 16px;
      margin-right: 16px;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Poppins', 'Aptos', Arial, sans-serif;
    }

    canvas {
      display: block;
    }
  </style>
  <link href="https://fonts.googleapis.com/css?family=Poppins:400&display=swap" rel="stylesheet">
</head>
<body>
<!-- Game Title and Start Button -->
<div id="gameTitleScreen">
  <h1 id="gameTitle">My Car Geem</h1>
  <button id="startButton">Start Game</button>
</div>

<!-- Sidebar -->
<div id="sidebar">
  <button id="toggleCarPickerBtn">Car Picker</button>
</div>

<!-- Car Picker UI -->
<div id="carPicker">
  <h1>Pick a Car</h1>
  <div id="gridContainer">
    <div id="gridItem1" class="gridItem"></div>
    <div id="gridItem2" class="gridItem"></div>
    <div class="gridItem"></div>
    <div class="gridItem"></div>
    <div class="gridItem"></div>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
  // Prevent the default context menu from appearing on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault(); // Disable the context menu (right-click)
  });
  let isGameStarted = false;
  // Function that handles the transition and game start
  function startGame() {
    if (isGameStarted) return; // Prevent multiple triggers
    isGameStarted = true;

    const gameTitleScreen = document.getElementById('gameTitleScreen');
    const speedDial = document.getElementById('speedDial');
    const sidebar = document.getElementById('sidebar');

    gameTitleScreen.style.opacity = '0';
    sidebar.style.display = 'flex';

    // Fade them in
    setTimeout(() => {
      sidebar.style.opacity = '1';
    }, 0);

    // Remove title screen after fade
    setTimeout(() => {
      gameTitleScreen.style.display = 'none';
    }, 500);
  }

  // Toggle visibility of the Car Picker UI
  function toggleCarPicker() {
    const carPicker = document.getElementById('carPicker');
    if (carPicker.style.display === 'none' || carPicker.style.display === '') {
      carPicker.style.display = 'flex'; // Show Car Picker
    } else {
      carPicker.style.display = 'none'; // Hide Car Picker
    }
  }

  window.onload = () => {
    document.getElementById('startButton').onclick = startGame;
    document.getElementById('toggleCarPickerBtn').addEventListener('click', toggleCarPicker);

    let displayMessageTimeout = null;

    document.getElementById('gridItem1').addEventListener('click', function() {
      const displayMessage = document.getElementById("displayMessage");
      if (block && blockBeingUsed) {
        displayMessage.textContent = "You already in a car! Try exiting first.";
        displayMessage.style.display = "grid";
        void displayMessage.offsetWidth; // Force reflow
        displayMessage.style.opacity = "1";
        // Clear any previous timeout
        if (displayMessageTimeout) clearTimeout(displayMessageTimeout);
        // Fade out after 5 seconds
        displayMessageTimeout = setTimeout(() => {
          displayMessage.style.opacity = "0";
          setTimeout(() => {
            if (displayMessage.style.opacity === "0") {
              displayMessage.style.display = "none";
              displayMessage.textContent = "";
            }
          }, 1500);
        }, 3500);
        return;
      }
      spawnCar();
      carPicker.style.display = 'none';
    });

    // Walkable block controls
    document.addEventListener("keydown", e => walkKeys[e.code] = true);
    document.addEventListener("keyup", e => delete walkKeys[e.code]);
  };

  let camera, scene, renderer;
  let block;
  let blockPosition = new THREE.Vector3(0, 0, 0);
  let blockRotation = new THREE.Vector3(0, 0, 0);
  let targetBlockRotation = new THREE.Vector3(0, 0, 0); // Target rotation for lerp
  let velocity = 0;
  let mph = 0;
  const maxSpeed = 2;

  let gearMode = "";
  if (block && blockBeingUsed) gearMode = "neutral"; // Start in neutral gear
  let gear = 0;

  let cameraOffsetZ = 5;
  let cameraOffsetX = 0;
  let targetCameraOffsetZ = cameraOffsetZ;
  let targetCameraOffsetX = cameraOffsetX;
  const cameraMoveDistance = 0.2;
  const cameraMoveSpeed = 0.025;

  let walkableBlock;
  let walkableBlockRotation = new THREE.Vector3(0, 0, 0);
  let walkableBlockSpeed = 0.12;
  const walkKeys = {};

  let blockBeingUsed = false;

  let spaceHeldStart = null;
  let spaceHeldTimeout = 2000; // 2 seconds in ms 

  let targetFov = 80;
  const maxFov = 90;
  const minFov = 70;
  const fovSpeed = 0.0003625;
  const fovBoostSpeed = 0.0003625;
  const keys = {};

const world = new CANNON.World();
world.gravity.set(0, -9.82, 0); // Standard earth gravity

const groundMaterial = new CANNON.Material("groundMaterial");
const blockMaterial = new CANNON.Material("blockMaterial");

// Contact material: controls friction and restitution between block and ground
const contactMaterial = new CANNON.ContactMaterial(
  groundMaterial,
  blockMaterial,
  {
    friction: 0,
    restitution: 0 // No bounce
  }
);
world.addContactMaterial(contactMaterial);

// Create a static ground plane in Cannon.js
const groundBody = new CANNON.Body({
  mass: 0,
  shape: new CANNON.Plane(),
  position: new CANNON.Vec3(0, 0, 0),
  material: groundMaterial,
  collisionFilterGroup: 2,
  collisionFilterMask: 1
});
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

function createBlock(x, y, z, width, height, depth, color, mass = 1, collidability = false) {
  // THREE.js mesh
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshPhongMaterial({ color: color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  scene.add(mesh);

  // Cannon.js body
  const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
  const body = new CANNON.Body({
    mass: mass, // 0 for static, 1 for dynamic
    position: new CANNON.Vec3(x, y, z),
    shape: shape,
    material: blockMaterial
  });

  // --- DISABLE COLLISION BETWEEN BLOCKS (EXCEPT GROUND) ---
  // Only enable collision with the ground (collisionFilterGroup = 1, collisionFilterMask = 2 for ground)
  // We'll use group 1 for blocks, group 2 for ground
  // For ground:
  //   collisionFilterGroup: 2, collisionFilterMask: 1
  // For blocks:
  //   collisionFilterGroup: 1, collisionFilterMask: 2
  if (mass > 0) {
    body.collisionFilterGroup = 1;
    body.collisionFilterMask = 2;
  } else {
    // static blocks (walls) - still only collide with ground
    body.collisionFilterGroup = 1;
    body.collisionFilterMask = 2;
  }

  world.addBody(body);

  mesh.userData.body = body; // Link mesh to body
  mesh.userData.collidability = collidability; // Store collidability flag
  body.collidability = collidability; // Also store on body for easy access

  return mesh;
}

function syncPhysics() {
  // Sync block
  if (block && block.userData.body) {
    block.position.copy(block.userData.body.position);
    block.quaternion.copy(block.userData.body.quaternion);
  }
  // Sync walkableBlock
  if (walkableBlock && walkableBlock.userData.body) {
    walkableBlock.position.copy(walkableBlock.userData.body.position);
    walkableBlock.quaternion.copy(walkableBlock.userData.body.quaternion);
    // --- Force walkableBlock to face camera's yaw after physics sync ---
    walkableBlock.rotation.set(0, orbitTheta, 0);
  }
}

function spawnCar() {
  if (block) {
    scene.remove(block);
    if (block.userData.body) world.removeBody(block.userData.body);
    block.geometry.dispose();
    block.material.dispose();
    block = null;
  }

  let left = new THREE.Vector3(1, 0, 0);
  left.applyQuaternion(walkableBlock.quaternion);
  left.y = 0;
  left.normalize();
  let spawnPos = walkableBlock.position.clone().add(left.multiplyScalar(4));

  block = createBlock(spawnPos.x, spawnPos.y - 0.2125, spawnPos.z, 2.25, 1.5, 4, 0xff00ff);
  if (block) {
    blockPosition.copy(spawnPos);

    // Copy walkableBlock's rotation to block
    block.rotation.copy(walkableBlock.rotation);
    block.quaternion.copy(walkableBlock.quaternion);

    // Set Cannon.js body quaternion to match walkableBlock
    if (block.userData.body) {
      block.userData.body.quaternion.copy(block.quaternion);
    }

    blockRotation.copy(walkableBlock.rotation);
    targetBlockRotation.copy(walkableBlock.rotation);

    velocity = 0;
    mph = 0;
    gearMode = "neutral";
    blockEnterCount = 0;
    const carPicker = document.getElementById('carPicker');
    if (carPicker) carPicker.style.display = 'none';

    // --- Lock camera behind block if blockBeingUsed (but still allow pan) ---
    if (block && blockBeingUsed) {
      // Set orbitTheta so camera starts behind the block
      alignCameraToForward(block);
    }
  }
}

let blockEnterCount = 0;

function isPointInsideMesh(point, mesh, threshold = 0.2) {
  // Convert the point to mesh local space
  const localPoint = point.clone();
  mesh.worldToLocal(localPoint);

  // Get geometry
  const geometry = mesh.geometry;
  if (!geometry.attributes.position) return false;

  // For each triangle, check if the point is close to the triangle surface
  const pos = geometry.attributes.position;
  for (let i = 0; i < pos.count; i += 3) {
    const a = new THREE.Vector3().fromBufferAttribute(pos, i);
    const b = new THREE.Vector3().fromBufferAttribute(pos, i + 1);
    const c = new THREE.Vector3().fromBufferAttribute(pos, i + 2);

    // Compute closest point on triangle to localPoint
    const closest = new THREE.Vector3();
    closestPointToTriangle(localPoint, a, b, c, closest);

    // If the distance is less than threshold, consider it a hit
    if (localPoint.distanceTo(closest) < threshold) {
      return true;
    }
  }
  return false;
}

// Helper: Find closest point on triangle to a point
function closestPointToTriangle(p, a, b, c, target) {
  // Algorithm from Real-Time Collision Detection, Christer Ericson, 2005
  const ab = b.clone().sub(a);
  const ac = c.clone().sub(a);
  const ap = p.clone().sub(a);

  const d1 = ab.dot(ap);
  const d2 = ac.dot(ap);

  if (d1 <= 0 && d2 <= 0) {
    target.copy(a);
    return target;
  }

  const bp = p.clone().sub(b);
  const d3 = ab.dot(bp);
  const d4 = ac.dot(bp);

  if (d3 >= 0 && d4 <= d3) {
    target.copy(b);
    return target;
  }

  const vc = d1 * d4 - d3 * d2;
  if (vc <= 0 && d1 >= 0 && d3 <= 0) {
    const v = d1 / (d1 - d3);
    target.copy(a).add(ab.multiplyScalar(v));
    return target;
  }

  const cp = p.clone().sub(c);
  const d5 = ab.dot(cp);
  const d6 = ac.dot(cp);

  if (d6 >= 0 && d5 <= d6) {
    target.copy(c);
    return target;
  }

  const vb = d5 * d2 - d1 * d6;
  if (vb <= 0 && d2 >= 0 && d6 <= 0) {
    const w = d2 / (d2 - d6);
    target.copy(a).add(ac.multiplyScalar(w));
    return target;
  }

  const va = d3 * d6 - d5 * d4;
  if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
    const w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
    target.copy(b).add(c.clone().sub(b).multiplyScalar(w));
    return target;
  }

  // Inside face region
  const denom = 1 / (va + vb + vc);
  const v = vb * denom;
  const w = vc * denom;
  target.copy(a)
    .add(ab.multiplyScalar(v))
    .add(ac.multiplyScalar(w));
  return target;
}

// Replace the collision check in checkBlockContact() with this:
function checkBlockContact() {
  if (!walkableBlock || !block) {
    blockBeingUsed = false;
    return;
  }

  // Use precise mesh-based detection for both meshes
  const threshold = 0.6; // Adjust as needed for your models

  // Check if walkableBlock's center is inside block's mesh
  const walkableInBlock = isPointInsideMesh(walkableBlock.position, block, threshold);

  // Check if block's center is inside walkableBlock's mesh
  const blockInWalkable = isPointInsideMesh(block.position, walkableBlock, threshold);

  const collision = walkableInBlock || blockInWalkable;

  if (collision && !blockBeingUsed) {
    walkableBlock.position.copy(block.position);
    blockBeingUsed = true;
    spaceHeldStart = null;
    blockEnterCount++;
  }

  if (blockBeingUsed) {
    walkableBlock.position.copy(block.position);

    if (walkKeys["Space"]) {
      if (!spaceHeldStart) spaceHeldStart = Date.now();
      if (Date.now() - spaceHeldStart >= spaceHeldTimeout) {
        const ejectOffset = new THREE.Vector3(4, 0, 0);
        ejectOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), block.rotation.y);
        if (walkableBlock.userData.body) {
          walkableBlock.userData.body.position.copy(block.position);
          walkableBlock.userData.body.position.vadd(
            new CANNON.Vec3(ejectOffset.x, ejectOffset.y, ejectOffset.z),
            walkableBlock.userData.body.position
          );
          walkableBlock.userData.body.velocity.set(0, 0, 0);

          const q = new THREE.Quaternion();
          q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), orbitTheta);
          walkableBlock.userData.body.quaternion.copy(q);
          walkableBlock.quaternion.copy(q);
        }
        blockBeingUsed = false;
        spaceHeldStart = null;
      }
    } else {
      spaceHeldStart = null;
    }
  } else if (!collision) {
    spaceHeldStart = null;
    blockBeingUsed = false;
  }
  if (blockBeingUsed) {
    walkableBlock.visible = false;
  } else {
    walkableBlock.visible = true;
  }
}

  function init() {
    camera = new THREE.PerspectiveCamera(targetFov, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x80c7ff);

    const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
    const groundMaterial = new THREE.MeshPhysicalMaterial({ color: 0x4C7031, side: THREE.DoubleSide, roughness: 1 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.03125;
    scene.add(ground);

    const roadGeometry = new THREE.PlaneGeometry(12, 10000);
    const roadMaterial = new THREE.MeshPhysicalMaterial({ color: 0x333333, side: THREE.DoubleSide, roughness: 1 });
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.rotation.x = -Math.PI / 2;
    road.position.y = 0.03125;
    road.position.x = 0;
    scene.add(road);

    const lineGeometry = new THREE.BoxGeometry(0.0625, 10000, 0.1);
    const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00});
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    const line2 = new THREE.Mesh(lineGeometry, lineMaterial);
    line.rotation.x = -Math.PI / 2;
    line.position.y = 0;
    line2.rotation.x = -Math.PI / 2;
    line2.position.y = 0;
    line.position.x = 0.125;
    line2.position.x = -0.125;
    scene.add(line, line2);

    // Side blocks
    createBlock(16, 4, 0, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 32, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 64, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 96, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 128, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 160, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 192, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 224, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 256, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 288, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 320, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 352, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 384, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 416, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 448, 12, 8, 24, 0x0000ff, 0);
    createBlock(16, 4, 480, 12, 8, 24, 0x0000ff, 0);

    createBlock(-16, 4, 0, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 96, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 64, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 32, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 128, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 160, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 192, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 224, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 256, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 288, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 320, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 352, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 384, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 416, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 448, 12, 8, 24, 0x0000ff, 0);
    createBlock(-16, 4, 480, 12, 8, 24, 0x0000ff, 0);

    // --- SPAWN WALKABLE BLOCK ON LOAD ---
    walkableBlock = createBlock(0, 1.00125, 0, 1, 2, 1, 0x00ff00);
    alignCameraToForward(walkableBlock);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(2, 5, 2);
    scene.add(light);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // After creating your renderer and light, add these lines:

renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, more realistic shadows

// For your light:
light.castShadow = true;
light.shadow.bias = -0.001; // Helps reduce shadow acne
light.shadow.mapSize.width = 1024;
light.shadow.mapSize.height = 1024;

// Make the ground receive shadows and blocks cast shadows:
ground.receiveShadow = true;
if (walkableBlock) walkableBlock.castShadow = true;
if (block) block.castShadow = true;

// Make shadows less dark (lighter/softer):
renderer.shadowMap.autoUpdate = true;
// Optionally, use a lighter ambient light to brighten shadowed areas:
const ambient = new THREE.AmbientLight(0xffffff, 0.35); // Soft white light
scene.add(ambient);

    window.addEventListener("resize", onWindowResize);
    document.addEventListener("keydown", e => keys[e.code] = true);
    document.addEventListener("keyup", e => delete keys[e.code]);
  }

  let vToggle = false;

document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyV' && block && blockBeingUsed) {
    vToggle = !vToggle;
    if (vToggle) {
      targetOrbitRadius = 1;
      orbitRadius = 1;
      // Lock camera angle straight forward (behind the car)
      alignCameraToForward(block);
      // Optionally, lock phi to a fixed value (e.g., Math.PI/3 for a slight top-down, or Math.PI/2 for level)
      orbitPhi = Math.PI / 3;
    } else {
      targetOrbitRadius = 10; // Restore default orbit distance
    }
  }
});

function updateWalkableBlock() {
  if (!walkableBlock) return;

  // Calculate camera's forward and right vectors (projected onto XZ plane)
  const camForward = new THREE.Vector3();
  camera.getWorldDirection(camForward);
  camForward.y = 0;
  camForward.normalize();

  const camRight = new THREE.Vector3();
  camRight.crossVectors(camForward, new THREE.Vector3(0, 1, 0)).normalize();

  // Move relative to camera orientation
  let move = new THREE.Vector3();
  if (walkKeys["KeyW"]) move.add(camForward);
  if (walkKeys["KeyS"]) move.sub(camForward);
  if (walkKeys["KeyA"]) move.sub(camRight);
  if (walkKeys["KeyD"]) move.add(camRight);

  if (move.lengthSq() > 0) {
    move.normalize().multiplyScalar(walkableBlockSpeed);

    // --- Move the Cannon.js body, not just the mesh ---
    if (walkableBlock.userData.body) {
      walkableBlock.userData.body.position.x += move.x;
      walkableBlock.userData.body.position.z += move.z;
      walkableBlock.userData.body.velocity.x = 0;
      walkableBlock.userData.body.velocity.z = 0;
    }
  }

  // --- Make walkableBlock rotate to face the same direction as the orbit camera (panned yaw) ---
  walkableBlock.rotation.set(0, orbitTheta, 0);
}

// --- ORBIT CAMERA LOGIC ---
let orbitRadius = 10;
let orbitTheta = 0; // Will be set dynamically to match local forward
let orbitPhi = Math.PI / 3;
let isOrbitDragging = false;
let lastOrbitX = 0, lastOrbitY = 0;

function alignCameraToForward(mesh) {
  const forward = new THREE.Vector3(0, 0, -1); // Local forward in mesh space
  forward.applyQuaternion(mesh.quaternion); // Convert to world space
  orbitTheta = Math.atan2(-forward.x, -forward.z); // Calculate theta from forward vector
}


function updateOrbitCamera(target) {
  // If vToggle is active, lock camera angle straight behind the car
  if (vToggle && block && blockBeingUsed) {
    alignCameraToForward(block);
    orbitPhi = Math.PI / 3; // Or Math.PI/2 for level, adjust as desired
  }
  // Clamp phi to avoid flipping
  const eps = 0.01;
  orbitPhi = Math.max(eps, Math.min(Math.PI - eps, orbitPhi));

  // Camera offset in spherical coordinates
  const offset = new THREE.Vector3(
    orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta),
    orbitRadius * Math.cos(orbitPhi),
    orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta)
  );

  camera.position.x = target.x + offset.x;
  camera.position.y = target.y + offset.y;
  camera.position.z = target.z + offset.z;
  camera.lookAt(target.x, target.y, target.z);
}

function onOrbitPointerMove(event) {
    if (vToggle) return; // Disable panning/dragging when V toggle is active
  if (!isOrbitDragging) return;
  const deltaX = event.clientX - lastOrbitX;
  const deltaY = event.clientY - lastOrbitY;
  lastOrbitX = event.clientX;
  lastOrbitY = event.clientY;
  // Reverse left/right direction, 0.4x sensitivity
  orbitTheta -= deltaX * 0.002;
  orbitPhi -= deltaY * 0.002;
}

function onOrbitPointerDown(event) {
    if (vToggle) return; // Disable panning/dragging when V toggle is active
  isOrbitDragging = true;
  lastOrbitX = event.clientX;
  lastOrbitY = event.clientY;
}

function onOrbitPointerUp() {
  isOrbitDragging = false;
}

// Mouse wheel for zoom
let targetOrbitRadius = orbitRadius;

let firstPerson = false; // Track if in first-person mode

function onOrbitWheel(event) {
  if (vToggle) return;
  targetOrbitRadius += event.deltaY * 0.001 * orbitRadius; // Adjust zoom sensitivity
  targetOrbitRadius = Math.max(5, Math.min(targetOrbitRadius, 35));
  if (keys["v"] && block && blockBeingUsed && firstPerson === false) {
    // copilot, make it so that the camera locks into max zoom when v is pressed
    targetOrbitRadius = 0;
    isOrbitDragging = false;
    targetOrbitRadius = Math.max(0, Math.min(targetOrbitRadius, 0));
    firstPerson = true;
  } else if (keys["v"] && block && blockBeingUsed && firstPerson === true) {
    // copilot, make it so that the camera unlocks when v is pressed again
    targetOrbitRadius = 10;
    isOrbitDragging = true;
    targetOrbitRadius = Math.max(5, Math.min(targetOrbitRadius, 35));
    firstPerson = false;
  }
}

// Attach orbit camera controls to renderer dom
document.addEventListener('pointerdown', onOrbitPointerDown);
document.addEventListener('pointermove', onOrbitPointerMove);
document.addEventListener('pointerup', onOrbitPointerUp);
document.addEventListener('pointerleave', onOrbitPointerUp);
document.addEventListener('wheel', onOrbitWheel);

  function getAccelerationForSpeed(speed) {
    const accelMap = [
      { speed: 0.00125, accel: 0.0016 * 1.0, useLerp: true, gear: 1 }, 
      { speed: 0.05, accel: 0.0016 * 1.0, useLerp: true },
      { speed: 0.1, accel: 0.0020* 1.0, useLerp: true },

      { speed: 0.2513, accel: 0.0025 * 0.9, useLerp: false },  // 13 mph before
      { speed: 0.2533, accel: 0.000035, useLerp: false },  // 13 mph
      { speed: 0.2553, accel: 0.0025 * 0.9, useLerp: true, gear: 2 },  // 13 mph after
      
      { speed: 0.3233, accel: 0.0026 * 0.9, useLerp: true },

      { speed: 0.4847, accel: 0.0028 * 0.8, useLerp: false },  // 26 mph before
      { speed: 0.4867, accel: 0.000040, useLerp: false },  // 26 mph
      { speed: 0.4887, accel: 0.0028 * 0.8, useLerp: true, gear: 3 },  // 26 mph after

      { speed: 0.5233, accel: 0.0026 * 0.8, useLerp: true },

      { speed: 0.8413, accel: 0.0025 * 0.7, useLerp: false },  // 40 mph before
      { speed: 0.8433, accel: 0.000035, useLerp: false },  // 40 mph
      { speed: 0.8453, accel: 0.0025 * 0.7, useLerp: true, gear: 4 },  // 40 mph after

      { speed: 0.9833, accel: 0.0023 * 0.7, useLerp: true },

      { speed: 1.2813, accel: 0.0021 * 0.6, useLerp: false },  // 61 mph before
      { speed: 1.2833, accel: 0.000030, useLerp: false },  // 61 mph
      { speed: 1.2853, accel: 0.0021 * 0.6, useLerp: true, gear: 5 },  // 61 mph after

      { speed: 1.45, accel: 0.0019 * 0.6, useLerp: true },
      { speed: 1.6, accel: 0.0016 * 0.6, useLerp: true },

      { speed: 1.75, accel: 0.0007 * 0.6, useLerp: true },
      { speed: 1.9, accel: 0.0003 * 0.6, useLerp: true }
    ];

    const absSpeed = Math.abs(speed);

    if (absSpeed <= accelMap[0].speed) return accelMap[0].accel;
    if (absSpeed >= accelMap[accelMap.length - 1].speed) return accelMap[accelMap.length - 1].accel;

    for (let i = 0; i < accelMap.length - 1; i++) {
      const s1 = accelMap[i].speed;
      const s2 = accelMap[i + 1].speed;
      if (absSpeed >= s1 && absSpeed <= s2) {
        const a1 = accelMap[i].accel;
        const a2 = accelMap[i + 1].accel;
        const t = (absSpeed - s1) / (s2 - s1);
        
        if (accelMap[i].useLerp && accelMap[i + 1].useLerp) {
          // Apply lerp for tweaked values
          return a1 + t * (a2 - a1);
        } else {
          // If not tweaked, just return the current acceleration value without lerp
          return a1;
        }
      }
    }

    return 0.0007;
  }


  function getFovForSpeed(speed) {
    const fovMap = [
      { speed: 0.0, fov: 75 },
      { speed: 0.1, fov: 75.5 },
      { speed: 0.3, fov: 76 },
      { speed: 0.6, fov: 77 },
      { speed: 0.8, fov: 78 },
      { speed: 1.0, fov: 79 },
      { speed: 1.3, fov: 81 },
      { speed: 1.6, fov: 83 },
      { speed: 2.0, fov: 84 }
    ];
    const absSpeed = Math.abs(speed);

    if (absSpeed <= fovMap[0].speed) return fovMap[0].fov;
    if (absSpeed >= fovMap[fovMap.length - 1].speed) return fovMap[fovMap.length - 1].fov;

    for (let i = 0; i < fovMap.length - 1; i++) {
      const s1 = fovMap[i].speed;
      const s2 = fovMap[i + 1].speed;
      if (absSpeed >= s1 && absSpeed <= s2) {
        const f1 = fovMap[i].fov;
        const f2 = fovMap[i + 1].fov;
        const t = (absSpeed - s1) / (s2 - s1);
        return f1 + t * (f2 - f1);
      }
    }

    return 75;  // Default FOV value
  }

  function getFovForReversing(speed) {
    const reverseFovMap = [
      { speed: 0.0, fov: 75 },
      { speed: 0.1, fov: 75.5 },
      { speed: 0.3, fov: 76 },
    ];

    let absSpeed = Math.abs(speed);
    let closest = 0;
    for (const key of reverseFovMap.keys()) {
      if (absSpeed >= key) closest = key;
    }
    return reverseFovMap.get(closest);
  }

  function getRotationSpeedForSpeed(speed) {
    const rotationMap = [
      { speed: 0.00125, rotation: 0.0 },
      { speed: 0.05, rotation: 0.00650 },
      { speed: 0.1, rotation: 0.00825 },
      { speed: 0.2, rotation: 0.00850 },
      { speed: 0.3, rotation: 0.00875 },
      { speed: 0.4, rotation: 0.008875 },
      { speed: 0.5, rotation: 0.00875 },
      { speed: 0.6, rotation: 0.00850 },
      { speed: 0.7, rotation: 0.008375 },
      { speed: 0.8, rotation: 0.00825 },
      { speed: 0.9, rotation: 0.00800 },
      { speed: 1.0, rotation: 0.00750 },
      { speed: 1.2, rotation: 0.00650 },
      { speed: 1.4, rotation: 0.00525 },
      { speed: 1.6, rotation: 0.00425 },
      { speed: 1.8, rotation: 0.00400 }
    ];

    const absSpeed = Math.abs(speed);

    if (absSpeed <= rotationMap[0].speed) return rotationMap[0].rotation;
    if (absSpeed >= rotationMap[rotationMap.length - 1].speed) return rotationMap[rotationMap.length - 1].rotation;

    for (let i = 0; i < rotationMap.length - 1; i++) {
      const s1 = rotationMap[i].speed;
      const s2 = rotationMap[i + 1].speed;
      if (absSpeed >= s1 && absSpeed <= s2) {
        const r1 = rotationMap[i].rotation;
        const r2 = rotationMap[i + 1].rotation;
        const t = (absSpeed - s1) / (s2 - s1);
        return r1 + t * (r2 - r1);
      }
    }

    return 0.05;
  }

  // Define a map for braking intensity per speed
  function getBrakeForSpeed(speed) {
    const brakeMap = [
      { speed: 0.05, brake: 0.0016 },
      { speed: 0.1, brake: 0.0021 },
      { speed: 0.2, brake: 0.0023 },
      { speed: 0.4, brake: 0.0022 },
      { speed: 0.7, brake: 0.0021 },
      { speed: 1.1, brake: 0.0020 },
      { speed: 1.6, brake: 0.0019 },
      { speed: 1.8, brake: 0.0018 },
      { speed: 1.95, brake: 0.0016 }
    ];

    const absSpeed = Math.abs(speed);

    if (absSpeed <= brakeMap[0].speed) return brakeMap[0].brake;
    if (absSpeed >= brakeMap[brakeMap.length - 1].speed) return brakeMap[brakeMap.length - 1].brake;

    for (let i = 0; i < brakeMap.length - 1; i++) {
      const s1 = brakeMap[i].speed;
      const s2 = brakeMap[i + 1].speed;
      if (absSpeed >= s1 && absSpeed <= s2) {
        const b1 = brakeMap[i].brake;
        const b2 = brakeMap[i + 1].brake;
        const t = (absSpeed - s1) / (s2 - s1);
        return b1 + t * (b2 - b1);
      }
    }

    return 0.0010; // default brake value
  }

  function getMaxRollForSpeed(speed) {
    const rollMap = [
      { speed: 0.0, maxRoll: 0.0 },
      { speed: 0.3333, maxRoll: 0.4 },
      { speed: 0.6666, maxRoll: 0.8 },
      { speed: 1.0, maxRoll: 1.2 },
      { speed: 1.3333, maxRoll: 1.6 },
      { speed: 1.6666, maxRoll: 1.8 },
      { speed: 2.0, maxRoll: 2 },
    ];

    const absSpeed = Math.abs(speed);

    if (absSpeed <= rollMap[0].speed) return rollMap[0].maxRoll;
    if (absSpeed >= rollMap[rollMap.length - 1].speed) return rollMap[rollMap.length - 1].maxRoll;

    for (let i = 0; i < rollMap.length - 1; i++) {
      const s1 = rollMap[i].speed;
      const s2 = rollMap[i + 1].speed;
      if (absSpeed >= s1 && absSpeed <= s2) {
        const r1 = rollMap[i].maxRoll;
        const r2 = rollMap[i + 1].maxRoll;
        const t = (absSpeed - s1) / (s2 - s1);
        return r1 + t * (r2 - r1);
      }
    }

    return 0.0;
  }

  let rollAmount = 0;  // Actual roll applied (in degrees)
  let targetRollAmount = 0;  // Smoothed target roll
  let maxRoll = 0.5;  // Max roll limit in degrees (initialized to a default)

  let qPressedLastFrame = false;
  let ePressedLastFrame = false;
  let tiltForwardKeyHeld = false;
  let tiltTargetReached = false;
  let previousVelocity = 0;
  let tiltAmount = 0; // current tilt
  let tiltStrength = 0.025; // how fast tilt changes
  let maxTiltAngle = -1.5; // max degrees tilt forward/back

  function updateBlock() {
    if (!block) return;
    const forward = keys["KeyW"];
    const backward = keys["KeyS"];
    const toggleReverseOn = keys["KeyQ"];
    const toggleReverseOff = keys["KeyE"];
    const left = keys["KeyA"];
    const right = keys["KeyD"];

    mph = Math.abs(velocity) * 51.5;
    // Update max roll based on the current speed
    maxRoll = getMaxRollForSpeed(velocity) * 0.8;

    // Get dynamic rotation speed based on the block's velocity
    let rotationSpeed = getRotationSpeedForSpeed(velocity);

    if (blockBeingUsed && block && block.userData.body) {
  // Calculate direction vector
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetBlockRotation.y);
  direction.normalize();

  // Set Cannon.js velocity (scale as needed)
  block.userData.body.velocity.x = direction.x * velocity * 60;
  block.userData.body.velocity.y = block.userData.body.velocity.y; // preserve vertical velocity (gravity)
  block.userData.body.velocity.z = direction.z * velocity * 60;
}

let steeringInput = 0;
if (left) steeringInput += 1;
if (right) steeringInput -= 1;

// Use the roll value from your map, scaled by steering direction
let rollTarget = steeringInput * maxRoll;

// Smoothly interpolate the actual roll amount toward the target
rollAmount = THREE.MathUtils.lerp(rollAmount, rollTarget, 0.1);

targetBlockRotation.z = THREE.MathUtils.degToRad(rollAmount);

    // --- Calculate acceleration (change in velocity) ---
    let accelSpeed = Math.abs(velocity) - Math.abs(previousVelocity);

    // Determine target tilt angle based on acceleration
    let tiltDirection = 0;

    if (accelSpeed > 0.001) {
      // Accelerating
      tiltDirection = gearMode === "reverse" ? -1 : 1; // Flip in reverse
    } else if (accelSpeed < -0.001) {
      // Braking
      tiltDirection = gearMode === "reverse" ? 1 : -1; // Flip in reverse
    }

    // Calculate target tilt angle in radians
    let targetTiltRad = THREE.MathUtils.degToRad(tiltDirection * maxTiltAngle);

    // Smoothly lerp tiltAmount toward target tilted
    tiltAmount = THREE.MathUtils.lerp(tiltAmount, targetTiltRad, tiltStrength);

    // Apply tilt to block's X rotation (pitch)
    targetBlockRotation.x = tiltAmount;

    // Store current velocity for next frame's comparison
    previousVelocity = velocity;

if (blockBeingUsed) {
  // --- Gear switching ---
  if (toggleReverseOn && !qPressedLastFrame) {
    if (gearMode === "drive") {
      gearMode = "neutral";
    } else if (gearMode === "neutral" && velocity <= 0) {
      gearMode = "reverse";
    }
  }
  if (toggleReverseOff && !ePressedLastFrame) {
    if (gearMode === "reverse") {
      gearMode = "neutral";
    } else if (gearMode === "neutral" && velocity >= 0) {
      gearMode = "drive";
    }
  }

  // --- Input direction ---
  let inputDir = forward ? 1 : 0;
  if (gearMode === "reverse") inputDir *= -1;
  if (gearMode === "neutral") inputDir = 0;

  // --- Acceleration/braking ---
  if (inputDir !== 0 ) {
    if ((velocity >= 0.00125 && inputDir > 0) || (velocity <= -0.00125 && inputDir < 0) || velocity === 0) {
      const accel = getAccelerationForSpeed(velocity);
      velocity += accel * inputDir;
    }
  } else if (!((velocity >= 0.00125 && inputDir > 0) || (velocity <= -0.00125 && inputDir < 0) || velocity === 0) && inputDir === 0 && backward) {
    const brake = getBrakeForSpeed(velocity);
    velocity -= brake * Math.sign(velocity) * 2;
    if (Math.abs(velocity) < 0.00125) velocity = 0;
  } else if (!((velocity >= 0.00125 && inputDir > 0) || (velocity <= -0.00125 && inputDir < 0) || velocity === 0)) {
    const brake = getBrakeForSpeed(velocity);
    velocity -= brake * Math.sign(velocity) * 0.7;
    if (Math.abs(velocity) < 0.00125) velocity = 0;
  }

  // --- Velocity clamping ---
  if (gearMode === "reverse") {
    velocity = THREE.MathUtils.clamp(velocity, -0.2533, maxSpeed);
  } else if (gearMode === "drive") {
    velocity = THREE.MathUtils.clamp(velocity, 0, 2);
  } else {
    velocity = THREE.MathUtils.clamp(velocity, -maxSpeed, maxSpeed);
  }

  // --- Steering (A/D) ---
  if (keys["KeyA"]) {
    if (velocity >= 0) {
      targetBlockRotation.y += rotationSpeed;
    } else if (velocity <= 0) {
      targetBlockRotation.y -= rotationSpeed;
    }
  }
  if (keys["KeyD"]) {
    if (velocity >= 0) {
      targetBlockRotation.y -= rotationSpeed;
    } else if (velocity <= 0) {
      targetBlockRotation.y += rotationSpeed;
    }
  }

  // --- Move block ---
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetBlockRotation.y);
  direction.multiplyScalar(velocity);
  blockPosition.add(direction);
} else {
  // --- Coast: move in last direction, apply friction ---
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetBlockRotation.y);
  direction.multiplyScalar(velocity);
  blockPosition.add(direction);

  // Apply friction to gradually slow down
  velocity *= 0.98;
  if (Math.abs(velocity) < 0.001) velocity = 0;
}

    // Calculate and apply FOV based on speed
    targetFov = getFovForSpeed(velocity);

    // Apply FOV to the camera
    camera.fov = targetFov;
    camera.updateProjectionMatrix();

    if (blockBeingUsed) {
      document.getElementById("speedDial").textContent =
      `Speed: ${Math.abs(velocity.toFixed(2))} (${Math.abs(mph.toFixed(0))} mph) | Gear: ${gearMode}`;
      document.getElementById("speedDial").style.display = "grid"; // Hide speed dial if not using the block
    } else {
      document.getElementById("speedDial").style.display = "none"; // Hide speed dial if not using the block
    }
  }

let lastBlockBeingUsed = false;

function animate() {
  requestAnimationFrame(animate);

  updateWalkableBlock();
  checkBlockContact();
  world.step(1/60); // Step physics

  syncPhysics();    // Sync mesh positions

  // --- ORBIT CAMERA FOLLOWS BLOCK OR WALKABLE BLOCK ---
  let target = walkableBlock ? walkableBlock.position : new THREE.Vector3(0, 0, 0);

  // Lock camera to local forward of block or walkableBlock when switching
if (block) {
  if (blockBeingUsed && !lastBlockBeingUsed) {
    alignCameraToForward(block);
  } else if (!blockBeingUsed && lastBlockBeingUsed && walkableBlock) {
    alignCameraToForward(walkableBlock);
  }
  // Set camera target based on whether player is in the car
  if (blockBeingUsed) {
    target = block.position;
  } else if (walkableBlock) {
    target = walkableBlock.position;
  }
  block.position.lerp(blockPosition, 0.1);

  // Only update rotation if player is in the car
if (blockBeingUsed) {
  blockRotation.lerp(targetBlockRotation, 0.1);

  // Compose rotation using quaternions in Z (roll), X (pitch), Y (yaw) order
  const pitchQuat = new THREE.Quaternion();
  pitchQuat.setFromAxisAngle(new THREE.Vector3(-1, 0, 0), blockRotation.x);

  const yawQuat = new THREE.Quaternion();
  yawQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), blockRotation.y);

  const rollQuat = new THREE.Quaternion();
  rollQuat.setFromAxisAngle(new THREE.Vector3(0, 0, -1), blockRotation.z);
  
  // Compose: yaw * roll * pitch (Y * Z * X)
  const finalQuat = new THREE.Quaternion();
  finalQuat.multiplyQuaternions(yawQuat, rollQuat); // yaw * roll
  finalQuat.multiply(pitchQuat); // (yaw * roll) * pitch

  block.quaternion.copy(finalQuat);
}
}
  lastBlockBeingUsed = !!blockBeingUsed;

  orbitRadius += (targetOrbitRadius - orbitRadius) * 0.25;

  updateOrbitCamera(target);

  camera.updateProjectionMatrix();
  renderer.render(scene, camera);
}

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  init();
  animate();
  setInterval(updateBlock, 16);
</script>

<div id="speedDial"></div>
<div id="displayMessage"></div>

</body>
</html>